version: '3.8'

# Production Docker Compose for Synology NAS deployment via Portainer
#
# Usage:
#   1. Copy this file and .env.production to your NAS
#   2. In Portainer: Add Stack -> Upload -> select this file
#   3. Configure environment variables in Portainer
#   4. Deploy the stack
#   5. Run migrations: docker exec -it rag-backend alembic upgrade head

services:
  # PostgreSQL Database
  postgres:
    image: postgres:16-alpine
    container_name: rag-postgres
    restart: unless-stopped
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-raguser}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:?POSTGRES_PASSWORD is required}
      POSTGRES_DB: ${POSTGRES_DB:-ragdb}
    volumes:
      - ${DATA_PATH:-/volume1/docker/rag-system}/postgres_data:/var/lib/postgresql/data
    networks:
      - rag-internal
    deploy:
      resources:
        limits:
          memory: 512M
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-raguser} -d ${POSTGRES_DB:-ragdb}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

  # Redis for Celery broker and caching
  redis:
    image: redis:7-alpine
    container_name: rag-redis
    restart: unless-stopped
    command: redis-server --maxmemory 200mb --maxmemory-policy allkeys-lru
    volumes:
      - ${DATA_PATH:-/volume1/docker/rag-system}/redis_data:/data
    networks:
      - rag-internal
    deploy:
      resources:
        limits:
          memory: 256M
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s

  # Qdrant Vector Database
  qdrant:
    image: qdrant/qdrant:latest
    container_name: rag-qdrant
    restart: unless-stopped
    volumes:
      - ${DATA_PATH:-/volume1/docker/rag-system}/qdrant_data:/qdrant/storage
    environment:
      QDRANT__SERVICE__GRPC_PORT: 6334
    networks:
      - rag-internal
    deploy:
      resources:
        limits:
          memory: 1G
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:6333/readyz"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

  # FastAPI Backend
  backend:
    image: ${DOCKER_USERNAME:?DOCKER_USERNAME is required}/rag-backend:${IMAGE_TAG:-latest}
    container_name: rag-backend
    restart: unless-stopped
    user: "${PUID:-1000}:${PGID:-1000}"
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://${POSTGRES_USER:-raguser}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB:-ragdb}
      - REDIS_URL=redis://redis:6379/0
      - QDRANT_HOST=qdrant
      - QDRANT_PORT=6333
      - SECRET_KEY=${SECRET_KEY:?SECRET_KEY is required}
      - ENCRYPTION_KEY=${ENCRYPTION_KEY:?ENCRYPTION_KEY is required}
      - OPENAI_API_KEY=${OPENAI_API_KEY:-}
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY:-}
      - OLLAMA_BASE_URL=${OLLAMA_BASE_URL:-}
      - LLM_PROVIDER=${LLM_PROVIDER:-openai}
      - EMBEDDING_PROVIDER=${EMBEDDING_PROVIDER:-openai}
      # SMTP Email Settings
      - SMTP_HOST=${SMTP_HOST:-}
      - SMTP_PORT=${SMTP_PORT:-587}
      - SMTP_USER=${SMTP_USER:-}
      - SMTP_PASSWORD=${SMTP_PASSWORD:-}
      - SMTP_FROM_EMAIL=${SMTP_FROM_EMAIL:-}
      - SMTP_FROM_NAME=${SMTP_FROM_NAME:-RAG System}
      - SMTP_USE_TLS=${SMTP_USE_TLS:-true}
      - SMTP_USE_SSL=${SMTP_USE_SSL:-false}
      # CORS - add your frontend origin(s) here
      - CORS_ORIGINS=http://${NAS_HOST}:3000
    volumes:
      - ${DATA_PATH:-/volume1/docker/rag-system}/uploads:/app/uploads
    networks:
      - rag-internal
      - rag-external
    deploy:
      resources:
        limits:
          memory: 1G
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      qdrant:
        condition: service_healthy
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Celery Worker
  celery-worker:
    image: ${DOCKER_USERNAME}/rag-backend:${IMAGE_TAG:-latest}
    container_name: rag-celery-worker
    restart: unless-stopped
    user: "${PUID:-1000}:${PGID:-1000}"
    environment:
      - DATABASE_URL=postgresql://${POSTGRES_USER:-raguser}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB:-ragdb}
      - REDIS_URL=redis://redis:6379/0
      - QDRANT_HOST=qdrant
      - QDRANT_PORT=6333
      - SECRET_KEY=${SECRET_KEY}
      - ENCRYPTION_KEY=${ENCRYPTION_KEY}
      - OPENAI_API_KEY=${OPENAI_API_KEY:-}
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY:-}
      - OLLAMA_BASE_URL=${OLLAMA_BASE_URL:-}
      - LLM_PROVIDER=${LLM_PROVIDER:-openai}
      - EMBEDDING_PROVIDER=${EMBEDDING_PROVIDER:-openai}
      # SMTP Email Settings
      - SMTP_HOST=${SMTP_HOST:-}
      - SMTP_PORT=${SMTP_PORT:-587}
      - SMTP_USER=${SMTP_USER:-}
      - SMTP_PASSWORD=${SMTP_PASSWORD:-}
      - SMTP_FROM_EMAIL=${SMTP_FROM_EMAIL:-}
      - SMTP_FROM_NAME=${SMTP_FROM_NAME:-RAG System}
      - SMTP_USE_TLS=${SMTP_USE_TLS:-true}
      - SMTP_USE_SSL=${SMTP_USE_SSL:-false}
    volumes:
      - ${DATA_PATH:-/volume1/docker/rag-system}/uploads:/app/uploads
    networks:
      - rag-internal
    deploy:
      resources:
        limits:
          memory: 1G
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      qdrant:
        condition: service_healthy
    command: celery -A app.tasks.celery_app worker --loglevel=info --concurrency=2
    healthcheck:
      test: ["CMD", "celery", "-A", "app.tasks.celery_app", "inspect", "ping", "-d", "celery@$$HOSTNAME"]
      interval: 60s
      timeout: 30s
      retries: 3
      start_period: 60s

  # Celery Beat (Scheduler)
  celery-beat:
    image: ${DOCKER_USERNAME}/rag-backend:${IMAGE_TAG:-latest}
    container_name: rag-celery-beat
    restart: unless-stopped
    environment:
      - DATABASE_URL=postgresql://${POSTGRES_USER:-raguser}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB:-ragdb}
      - REDIS_URL=redis://redis:6379/0
      - QDRANT_HOST=qdrant
      - QDRANT_PORT=6333
      - SECRET_KEY=${SECRET_KEY}
      - ENCRYPTION_KEY=${ENCRYPTION_KEY}
    networks:
      - rag-internal
    deploy:
      resources:
        limits:
          memory: 256M
    depends_on:
      - celery-worker
    command: celery -A app.tasks.celery_app beat --loglevel=info
    healthcheck:
      test: ["CMD", "pgrep", "-f", "celery.*beat"]
      interval: 60s
      timeout: 10s
      retries: 3
      start_period: 30s

  # Next.js Frontend
  frontend:
    image: ${DOCKER_USERNAME}/rag-frontend:${IMAGE_TAG:-latest}
    container_name: rag-frontend
    restart: unless-stopped
    ports:
      - "3000:3000"
    environment:
      - NEXT_PUBLIC_API_URL=http://${NAS_HOST:?NAS_HOST is required}:8001
      - BACKEND_URL=http://backend:8000
    networks:
      - rag-internal
      - rag-external
    deploy:
      resources:
        limits:
          memory: 512M
    depends_on:
      backend:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

networks:
  # Internal network for service-to-service communication
  rag-internal:
    driver: bridge
    internal: true
  # External network for services that need outside access
  rag-external:
    driver: bridge

